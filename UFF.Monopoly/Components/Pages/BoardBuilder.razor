@page "/board-builder"
@page "/board-builder/{BoardId:guid}"
@using UFF.Monopoly.Entities
@using UFF.Monopoly.Data
@using UFF.Monopoly.Data.Entities
@using Microsoft.EntityFrameworkCore
@using Microsoft.AspNetCore.Components.Web
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject NavigationManager Nav

<h3>Board Builder</h3>

<div class="mb-3">
    <label class="form-label">Nome do tabuleiro</label>
    <input class="form-control" @bind="BoardName" />
</div>

<div class="row g-2 align-items-end mb-3">
    <div class="col-auto">
        <label class="form-label">Linhas</label>
        <input class="form-control" type="number" min="2" @bind="Rows" />
    </div>
    <div class="col-auto">
        <label class="form-label">Colunas</label>
        <input class="form-control" type="number" min="2" @bind="Cols" />
    </div>
    <div class="col-auto">
        <label class="form-label">Tamanho da célula (px)</label>
        <input class="form-control" type="number" min="20" @bind="CellSize" />
    </div>
    <div class="col-auto">
        <button class="btn btn-primary" @onclick="GenerateGrid">Gerar tabuleiro</button>
        <button class="btn btn-success ms-2" disabled="@(!Blocks?.Any() ?? true)" @onclick="SaveAsync">Salvar</button>
    </div>
</div>

@if (Rows > 0 && Cols > 0)
{
    <div class="board-wrapper" @onclick="ClosePopup">
        <div class="board-grid"
             style="grid-template-columns: repeat(@Cols, @($"{CellSize}px")); grid-auto-rows: @($"{CellSize}px");">
            @for (var r = 0; r < Rows; r++)
            {
                for (var c = 0; c < Cols; c++)
                {
                    if (CellToIndex.TryGetValue((r, c), out var index))
                    {
                        var b = index >= 0 && index < Blocks.Count ? Blocks[index] : null;
                        if (b is null)
                        {
                            <div class="grid-cell empty"></div>
                        }
                        else
                        {
                            <div class="grid-cell perimeter"
                                 style="background:@GetCellBackground(b); color:@GetTextColorForBackground(GetCellBackground(b));"
                                 title="@($"{b.Type} - {b.Name}")"
                                 @onclick="(e => OnCellClick(index, e))"
                                 @onclick:stopPropagation="true">
                                <div>
                                    <div class="cell-type">@b.Type</div>
                                    <div class="cell-index">@index</div>
                                </div>
                            </div>
                        }
                    }
                    else
                    {
                        <div class="grid-cell empty"></div>
                    }
                }
            }
        </div>

        @if (Popup.Visible)
        {
            <div class="type-popup" style="top:@($"{Popup.Y}px"); left:@($"{Popup.X}px");"
                 @onclick:stopPropagation="true">
                <div class="type-list">
                    @foreach (var t in Enum.GetValues<BlockType>())
                    {
                        <button class="type-option"
                                style="background:@GetTypeColor(t); color:@GetTextColorForBackground(GetTypeColor(t));"
                                @onclick="(() => SelectType(t))">
                            @t
                        </button>
                    }
                </div>
            </div>
        }
    </div>
}

@code {
    [Parameter]
    public Guid? BoardId { get; set; }

    private Guid CurrentBoardId;
    private string BoardName = string.Empty;

    private int Rows = 5;
    private int Cols = 5;
    private int CellSize = 64;

    private List<BlockTemplateEntity> Blocks = new();

    private Dictionary<(int r, int c), int> CellToIndex = new();

    private (bool Visible, int X, int Y, int Index) Popup;

    protected override async Task OnParametersSetAsync()
    {
        if (BoardId.HasValue && BoardId.Value != Guid.Empty && BoardId.Value != CurrentBoardId)
        {
            await LoadBoardAsync(BoardId.Value);
        }
    }

    private async Task LoadBoardAsync(Guid id)
    {
        await using var db = await DbFactory.CreateDbContextAsync();
        var board = await db.Boards.Include(b => b.Blocks).FirstOrDefaultAsync(b => b.Id == id);
        if (board is null)
        {
            return;
        }

        CurrentBoardId = id;
        BoardName = board.Name;
        Rows = board.Rows;
        Cols = board.Cols;
        CellSize = board.CellSizePx;

        Blocks = board.Blocks.OrderBy(b => b.Position).ToList();
        RebuildPerimeterMap();
        StateHasChanged();
    }

    private void GenerateGrid()
    {
        Rows = Math.Max(2, Rows);
        Cols = Math.Max(2, Cols);
        RebuildPerimeterMap();

        var total = CellToIndex.Count;
        Blocks = Enumerable.Range(0, total).Select(i => new BlockTemplateEntity
        {
            Id = Guid.NewGuid(),
            Position = i,
            Name = $"Bloco {i}",
            Type = BlockType.Property,
            Color = GetTypeColor(BlockType.Property),
            Price = 0,
            Rent = 0,
            BoardDefinitionId = CurrentBoardId
        }).ToList();
    }

    private void RebuildPerimeterMap()
    {
        var coords = BuildPerimeterClockwise(Rows, Cols);
        CellToIndex = new Dictionary<(int r, int c), int>(coords.Count);
        for (int i = 0; i < coords.Count; i++)
            CellToIndex[(coords[i].r, coords[i].c)] = i;
    }

    private static List<(int r, int c)> BuildPerimeterClockwise(int rows, int cols)
    {
        var list = new List<(int r, int c)>(Math.Max(0, 2 * rows + 2 * cols - 4));
        if (rows < 2 || cols < 2) return list;

        int bottom = rows - 1;
        int top = 0;
        int left = 0;
        int right = cols - 1;

        // Começa no canto inferior direito (GO) e vai para a esquerda
        for (int c = right; c >= left; c--)
            list.Add((bottom, c));

        // Sobe a coluna da esquerda (exclui o canto inferior esquerdo já adicionado)
        for (int r = bottom - 1; r >= top; r--)
            list.Add((r, left));

        // Vai para a direita na linha do topo (exclui o canto superior esquerdo)
        for (int c = left + 1; c <= right; c++)
            list.Add((top, c));

        // Desce a coluna da direita (exclui os cantos superior direito e inferior direito)
        for (int r = top + 1; r <= bottom - 1; r++)
            list.Add((r, right));

        return list;
    }

    private static (int rows, int cols) GuessDimensionsFromPerimeter(int perimeterCount)
    {
        // encontra par (r,c) tal que 2r + 2c - 4 == n, minimizando |r-c|
        if (perimeterCount < 4) return (2, 2);
        var best = (rows: 2, cols: Math.Max(2, perimeterCount / 2 + 1));
        var bestScore = int.MaxValue;
        for (int r = 2; r <= perimeterCount; r++)
        {
            var cNumerator = perimeterCount - 2 * r + 4;
            if (cNumerator <= 0) continue;
            if (cNumerator % 2 != 0) continue;
            int c = cNumerator / 2;
            if (c < 2) continue;
            var score = Math.Abs(r - c);
            if (score < bestScore)
            {
                bestScore = score;
                best = (r, c);
            }
        }
        return best;
    }

    private void OnCellClick(int index, MouseEventArgs e)
    {
        Popup = (true, (int)e.ClientX, (int)e.ClientY, index);
        StateHasChanged();
    }

    private void ClosePopup()
    {
        Popup.Visible = false;
        StateHasChanged();
    }

    private void SelectType(BlockType type)
    {
        var idx = Popup.Index;
        if (idx >= 0 && idx < Blocks.Count)
        {
            Blocks[idx].Type = type;
            Blocks[idx].Color = GetTypeColor(type);
            Blocks[idx].Name = type.ToString();
        }
        Popup.Visible = false;
        StateHasChanged();
    }

    private string GetCellBackground(BlockTemplateEntity b)
        => string.IsNullOrWhiteSpace(b.Color) ? GetTypeColor(b.Type) : b.Color;

    private string GetTypeColor(BlockType t) => t switch
    {
        BlockType.Go => "#27ae60",
        BlockType.Property => "#3498db",
        BlockType.Tax => "#e74c3c",
        BlockType.Jail => "#f1c40f",
        BlockType.GoToJail => "#d35400",
        _ => "#95a5a6"
    };

    private string GetTextColorForBackground(string? bg)
    {
        if (string.IsNullOrWhiteSpace(bg)) return "#111827";
        try
        {
            if (bg.StartsWith("#") && bg.Length == 7)
            {
                var r = Convert.ToInt32(bg.Substring(1, 2), 16);
                var g = Convert.ToInt32(bg.Substring(3, 2), 16);
                var b = Convert.ToInt32(bg.Substring(5, 2), 16);
                var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                return yiq >= 128 ? "#111827" : "#ffffff";
            }
        }
        catch { }
        return "#111827";
    }

    private async Task SaveAsync()
    {
        await using var db = await DbFactory.CreateDbContextAsync();
        var isNew = CurrentBoardId == Guid.Empty;

        if (isNew)
        {
            var newBoard = new BoardDefinitionEntity
            {
                Id = Guid.NewGuid(),
                Name = string.IsNullOrWhiteSpace(BoardName) ? $"Board {DateTime.UtcNow:yyyyMMddHHmmss}" : BoardName,
                Rows = Rows,
                Cols = Cols,
                CellSizePx = CellSize
            };
            db.Boards.Add(newBoard);
            await db.SaveChangesAsync();
            CurrentBoardId = newBoard.Id;
        }
        else
        {
            var boardOnly = new BoardDefinitionEntity { Id = CurrentBoardId };
            db.Attach(boardOnly);
            db.Entry(boardOnly).Property(x => x.Name).CurrentValue = BoardName;
            db.Entry(boardOnly).Property(x => x.Rows).CurrentValue = Rows;
            db.Entry(boardOnly).Property(x => x.Cols).CurrentValue = Cols;
            db.Entry(boardOnly).Property(x => x.CellSizePx).CurrentValue = CellSize;
            db.Entry(boardOnly).Property(x => x.Name).IsModified = true;
            db.Entry(boardOnly).Property(x => x.Rows).IsModified = true;
            db.Entry(boardOnly).Property(x => x.Cols).IsModified = true;
            db.Entry(boardOnly).Property(x => x.CellSizePx).IsModified = true;
            await db.SaveChangesAsync();

            var existing = await db.BlockTemplates
                .Where(x => x.BoardDefinitionId == CurrentBoardId)
                .ToListAsync();
            if (existing.Count > 0)
            {
                db.BlockTemplates.RemoveRange(existing);
                await db.SaveChangesAsync();
            }
        }

        var toInsert = new List<BlockTemplateEntity>(Blocks.Count);
        for (var i = 0; i < Blocks.Count; i++)
        {
            var b = Blocks[i];
            toInsert.Add(new BlockTemplateEntity
            {
                Id = Guid.NewGuid(),
                Position = i,
                Name = b.Name,
                Description = b.Description,
                ImageUrl = b.ImageUrl,
                Color = b.Color,
                Price = b.Price,
                Rent = b.Rent,
                Type = b.Type,
                BoardDefinitionId = CurrentBoardId
            });
        }
        db.BlockTemplates.AddRange(toInsert);
        await db.SaveChangesAsync();

        if (isNew)
        {
            Nav.NavigateTo($"/board-builder/{CurrentBoardId}");
        }
    }
}
