@using UFF.Monopoly.Entities
@inherits ComponentBase

@if (Game is not null)
{
    @for (int i = 0; i < Game.Players.Count; i++)
    {
        var p = Game.Players[i];
        if (p.IsBankrupt) continue;
        var renderIndex = (i == Game.CurrentPlayerIndex && PawnAnimPosition >= 0) ? PawnAnimPosition : p.CurrentPosition;
        var (top, left, z) = GetTokenOffsetPositionByBoardIndex(renderIndex, i);
        var pawnSize = (int)(CellSize * BoardScale * 0.5) + "px";
        var pawnUrl = GetPawnUrlForPlayer(i);
        <img src="@pawnUrl" alt="pawn" class="pawn-img"
             style="top:@top; left:@left; width:@pawnSize; height:@pawnSize; z-index:@z;" />
    }
}

@code {
    [Parameter] public Game? Game { get; set; }
    [Parameter] public int PawnAnimPosition { get; set; } = -1;
    [Parameter] public int CellSize { get; set; }
    [Parameter] public double BoardScale { get; set; } = 1.5;
    [Parameter] public List<(int r,int c)> Perimeter { get; set; } = new();
    [Parameter] public List<int> PawnIndexes { get; set; } = new();
    [Parameter] public string DefaultPawnUrl { get; set; } = "/images/pawns/PawnsB1.png";
    [Parameter] public Func<int,string>? PawnUrlResolver { get; set; }
    [Parameter] public double GutterX { get; set; } = 0.0;
    [Parameter] public double GutterY { get; set; } = 0.0;

    private string GetPawnUrlForPlayer(int playerIndex)
        => PawnUrlResolver?.Invoke(playerIndex) ?? (playerIndex < PawnIndexes.Count ? $"images/pawns/PawnsB{PawnIndexes[playerIndex]}.png" : DefaultPawnUrl);

    private (string top, string left, int z) GetTokenOffsetPositionByBoardIndex(int boardIndex, int playerIndex)
    {
        if (Perimeter.Count == 0)
            return ("0px", "0px", 1100);

        var (r, c) = Perimeter[Math.Clamp(boardIndex, 0, Perimeter.Count - 1)];

        // Use doubles for precise spacing; avoid premature integer truncation that breaks sparse boards
        var cellScaled = CellSize * BoardScale;
        var stepX = cellScaled + GutterX;
        var stepY = cellScaled + GutterY;

        // Center tokens within the cell even when gutters are large
        var baseTop = (r * stepY) + (cellScaled * 0.25);
        var baseLeft = (c * stepX) + (cellScaled * 0.25);

        double offsetX = 0, offsetY = 0;
        switch (playerIndex)
        {
            case 1: offsetX = cellScaled * 0.28; break;
            case 2: offsetY = cellScaled * 0.28; break;
            case 3: offsetX = cellScaled * 0.28; offsetY = cellScaled * 0.28; break;
        }

        // Nudge offsets to avoid overlap; scale nudges with cell size to remain consistent on sparse layouts
        if (offsetX > 0) offsetX += Math.Max(6, cellScaled * 0.04);
        if (offsetY > 0) offsetY += Math.Max(3, cellScaled * 0.02);

        var topPx = Math.Round(baseTop + offsetY);
        var leftPx = Math.Round(baseLeft + offsetX);
        return ($"{topPx}px", $"{leftPx}px", playerIndex >= 2 ? 1200 : 1100);
    }
}
