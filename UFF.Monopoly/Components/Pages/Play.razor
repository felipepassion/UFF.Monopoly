@page "/play/{GameId:guid}"

@using Microsoft.EntityFrameworkCore
@using UFF.Monopoly.Data
@using UFF.Monopoly.Data.Entities
@using UFF.Monopoly.Models
@using UFF.Monopoly.Repositories
@using UFF.Monopoly.Entities
@using System.Globalization
@using Microsoft.AspNetCore.WebUtilities
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject IGameRepository GameRepo
@inject NavigationManager Nav
@inject UFF.Monopoly.Infrastructure.IUserProfileService Profiles
@inject IJSRuntime JSRuntime

<h3 class="mb-2">Partida local</h3>

<div class="mt-2 d-flex align-items-md-center justify-content-center full-center-wrapper" style="min-height: calc(100vh - 140px);">
    <div class="board-shell d-inline-block" style="background:var(--surface);border:1px solid rgba(255,255,255,0.03);border-radius:10px;padding:10px;">
        @if (_loading)
        {
            <div class="p-4">Carregando...</div>
        }
        else if (_game is null)
        {
            <div class="p-4">Jogo não encontrado.</div>
        }
        else
        {
            <div id="game-board-container" class="game-board" style="position:relative; width:@_boardWidthCss; height:@_boardHeightCss; display:flex; align-items:center; justify-content:center;">

                @* Top-left: Rodada *@
                <div style="position:absolute; top:8px; left:8px; z-index:2500; background:rgba(0,0,0,0.35); padding:6px 8px; border-radius:6px; color:white; font-weight:600; transform:rotate(-12deg);">
                    Rodada: @_game.RoundCount
                </div>

                @* Top-right: Vez *@
                <div style="position:absolute; top:8px; right:8px; z-index:2500; background:rgba(0,0,0,0.35); padding:6px 8px; border-radius:6px; color:white; font-weight:600; transform:rotate(12deg);">
                    Vez: @_game.Players.ElementAtOrDefault(_game.CurrentPlayerIndex)?.Name
                </div>

                @foreach (var space in BoardSpaces)
                {
                    <BoardSpace Space="space" OnClick="HandleClick" />
                }

                @* Tokens for all players. For the active player, use _pawnAnimPosition when animating so token moves step-by-step *@
                @for (int i = 0; i < _game.Players.Count; i++)
                {
                    var p = _game.Players[i];
                    if (p.IsBankrupt) continue; // hide pawns of eliminated players
                    var renderIndex = (i == _game.CurrentPlayerIndex && _pawnAnimPosition >= 0) ? _pawnAnimPosition : p.CurrentPosition;
                    var (top, left, z) = GetTokenOffsetPositionByBoardIndex(renderIndex, i);
                    var pawnSize = (int)(CellSize * _boardScale * 0.5) + "px";
                    var pawnUrl = GetPawnUrlForPlayer(i);
                    <img src="@pawnUrl" alt="pawn"
                         style="position:absolute; width:@pawnSize; height:@pawnSize; object-fit:contain; top:@top; left:@left; transform:translate(20%,20%); transition: top @_animStepMs ms linear, left @_animStepMs ms linear; pointer-events:none; z-index:@z;" />
                }

                @if (_showDiceOverlay)
                {
                    var diceImgSize = Math.Max(24, (int)(CellSize * 0.6 * _boardScale)) + "px"; // scaled
                    var gifSize = Math.Max(64, (int)(CellSize * 1.6 * _boardScale)) + "px"; // scaled

                    var gifOffsetPx = -(int)(CellSize * 0.6 * _boardScale); // negative -> move up
                    var diceOffsetPx = (int)(CellSize * 0.8 * _boardScale); // positive -> move down
                    var gifOffset = gifOffsetPx + "px";
                    var diceOffset = diceOffsetPx + "px";

                    <div class="dice-overlay" style="position:absolute; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center; pointer-events:auto;">
                        <div class="dice-faces" style="display:flex; gap:12px; align-items:center; z-index:1; transform:translateY(@diceOffset);">
                            <img src="@($"{Nav.BaseUri}images/dice/diceGreen{_diceFace1}.png")" alt="die1" style="width:@diceImgSize; height:@diceImgSize; object-fit:contain; z-index:1; pointer-events:none;" />
                            <img src="@($"{Nav.BaseUri}images/dice/diceGreen{_diceFace2}.png")" alt="die2" style="width:@diceImgSize; height:@diceImgSize; object-fit:contain; z-index:1; pointer-events:none;" />
                        </div>
                        @if (!string.IsNullOrWhiteSpace(_rollingGifUrl))
                        {
                            <img src="@_rollingGifUrl" alt="rolling" style="position:absolute; z-index:2; width:@gifSize; height:@gifSize; object-fit:contain; pointer-events:none; opacity:0.95; transform:translateY(@gifOffset);" />
                        }
                    </div>
                }

                @* Post-move action modal *@
                @if (_showBlockModal && _modalBlock is not null && _modalPlayer is not null)
                {
                    // ensure modal appears above pawns (pawns z is ~1100-1200)
                    <div class="modal-backdrop show" style="z-index:20000;"></div>
                    <div class="modal d-block" tabindex="-1" style="z-index:20001;">
                        <div class="modal-dialog modal-md">
                            <div class="modal-content p-2" style="background:var(--surface);border:1px solid rgba(255,255,255,0.04);">
                                <div class="modal-header">
                                    @{
                                        var displayName = _modalTemplateEntity?.Name ?? _modalDisplayProperty?.Name ?? _modalBlock.Name;
                                    }
                                    <h5 class="modal-title">@displayName — @TranslateBlockType(_modalBlock.Type)</h5>
                                    <button type="button" class="btn-close btn-close-white" aria-label="Close" @onclick="CloseBlockModal"></button>
                                </div>
                                <div class="modal-body">
                                    @if (_modalBlock.Type == BlockType.Property || _modalBlock.Type == BlockType.Company)
                                    {
                                        var statePb = _modalBlock as PropertyBlock;
                                        var displayPb = _modalDisplayProperty ?? statePb ?? new PropertyBlock();
                                        var displayNameBody = displayPb.Name ?? _modalTemplateEntity?.Name ?? _modalBlock.Name;
                                        <div><strong>@( _modalBlock.Type == BlockType.Company ? "Companhia:" : "Propriedade:")</strong> @displayNameBody</div>
                                        <div><strong>Preço:</strong> R$ @displayPb.Price</div>
                                        @if (_modalBlock.Type == BlockType.Property)
                                        {
                                            <div><strong>Aluguel atual:</strong> R$ @displayPb.CalculateRent()</div>
                                            <div><strong>Casas:</strong> @(statePb?.Houses ?? displayPb.Houses) &nbsp; <strong>Hotéis:</strong> @(statePb?.Hotels ?? displayPb.Hotels)</div>
                                        }
                                        else
                                        {
                                            <div><strong>Aluguel fixo:</strong> R$ @_modalBlock.Rent</div>
                                        }
                                        <div class="mt-3">
                                            @if ((_modalBlock.Owner) is null)
                                            {
                                                <button id="btnBuy" class="btn btn-success me-2" @onclick="OnBuyPropertyAsync" disabled="@(_modalPlayer.Money < displayPb.Price)">Comprar (R$ @displayPb.Price)</button>
                                            }
                                            else if (statePb?.Owner == _modalPlayer)
                                            {
                                                <button id="btnBuildHouse" class="btn btn-primary me-2" @onclick="OnBuildHouseAsync" disabled="@(!(statePb is not null && CanBuildHouseAllowed(statePb)))">Construir casa (R$ @(statePb?.HousePrice ?? displayPb.HousePrice))</button>
                                                <button id="btnBuildHotel" class="btn btn-primary me-2" @onclick="OnBuildHotelAsync" disabled="@(!(statePb is not null && CanBuildHotelAllowed(statePb)))">Construir hotel (R$ @(statePb?.HotelPrice ?? displayPb.HotelPrice))</button>
                                                <button class="btn btn-outline-danger" @onclick="OnSellPropertyAsync">Vender propriedade (50%)</button>
                                            }
                                            else
                                            {
                                                <div class="text-muted">Propriedade de: @_modalBlock.Owner?.Name</div>
                                            }
                                        </div>
                                    }
                                    else if (_modalBlock.Type == BlockType.Chance || _modalBlock.Type == BlockType.Reves)
                                    {
                                        // show the pending outcome description
                                        if (_pendingActionKind == PendingActionKind.Chance)
                                        {
                                            <div>Você recebeu <strong>R$ @_pendingAmount</strong> da banca.</div>
                                        }
                                        else if (_pendingActionKind == PendingActionKind.Tax)
                                        {
                                            <div>Pagamento de taxa: <strong>R$ @_pendingAmount</strong></div>
                                        }
                                        else if (_pendingActionKind == PendingActionKind.Reves)
                                        {
                                            if (_pendingBackSteps > 0)
                                            {
                                                <div>Revés: você deverá voltar <strong>@_pendingBackSteps</strong> casas ao fechar.</div>
                                            }
                                            else
                                            {
                                                <div>Revés: você pagará <strong>R$ @_pendingAmount</strong> à banca.</div>
                                            }
                                        }
                                    }
                                    else if (_modalBlock.Type == BlockType.Tax)
                                    {
                                        <div>Pagamento de taxa: <strong>R$ @_pendingAmount</strong></div>
                                    }
                                    else if (_modalBlock.Type == BlockType.Go)
                                    {
                                        <div>Você chegou ao início / passou por ele e recebeu <strong>R$ @Game.GoSalary</strong>.</div>
                                    }
                                    else if (_modalBlock.Type == BlockType.GoToJail)
                                    {
                                        <div>Você foi enviado para a prisão.</div>
                                    }
                                    else
                                    {
                                        <div>@_modalBlock.Description</div>
                                    }
                                </div>
                                <div class="modal-footer">
                                    <button class="btn btn-secondary" @onclick="CloseBlockModal">Fechar</button>
                                </div>
                            </div>
                        </div>
                    </div>
                }

                @* Loser modal *@
                @if (_showLoserModal)
                {
                    <div class="modal-backdrop show" style="z-index:22000;"></div>
                    <div class="modal d-block" tabindex="-1" style="z-index:22001;">
                        <div class="modal-dialog modal-sm">
                            <div class="modal-content p-2" style="background:var(--surface);border:1px solid rgba(255,255,255,0.04);">
                                <div class="modal-header">
                                    <h5 class="modal-title">Derrota</h5>
                                </div>
                                <div class="modal-body">
                                    <div>O jogador <strong>@_loserName</strong> foi eliminado.</div>
                                </div>
                                <div class="modal-footer">
                                    <button class="btn btn-secondary" @onclick="CloseLoserModal">Fechar</button>
                                </div>
                            </div>
                        </div>
                    </div>
                }

                @* Winner modal *@
                @if (_showWinnerModal)
                {
                    <div class="modal-backdrop show" style="z-index:23000;"></div>
                    <div class="modal d-block" tabindex="-1" style="z-index:23001;">
                        <div class="modal-dialog modal-sm">
                            <div class="modal-content p-2" style="background:var(--surface);border:1px solid rgba(255,255,255,0.04);">
                                <div class="modal-header">
                                    <h5 class="modal-title">Vencedor</h5>
                                </div>
                                <div class="modal-body">
                                    <div>Parabéns! <strong>@_winnerName</strong> venceu o jogo.</div>
                                </div>
                                <div class="modal-footer">
                                    <button class="btn btn-primary" @onclick="CloseWinnerModal">Fechar</button>
                                </div>
                            </div>
                        </div>
                    </div>
                }

            </div>

            <div class="d-flex justify-content-between align-items-center mt-3">
                <div>
                    <div class="fw-bold">Jogadores</div>
                    <ul class="list-unstyled mb-0">
                        @for (int i = 0; i < _game.Players.Count; i++)
                        {
                            var p = _game.Players[i];
                            <li class="small">@p.Name = @p.Money</li>
                        }
                    </ul>
                </div>
                <div>
                    <button id="btnEnd" class="btn btn-secondary me-2" @onclick="EndGame">Encerrar</button>
                    <button id="btnRoll" class="btn btn-primary" @onclick="RollForCurrentPlayer" disabled="@(!CanRollForCurrent)">Rolar</button>
                </div>
                @if (_showBotActionToast)
                {
                    <div class="mt-2">
                        <div class="alert alert-info shadow-sm mb-0 py-1 px-2">@_botActionMessage</div>
                    </div>
                }
            </div>
        }
    </div>
</div>

@code {
    [Parameter]
    public Guid GameId { get; set; }

    [SupplyParameterFromQuery]
    public Guid? boardId { get; set; }

    [SupplyParameterFromQuery(Name = "humanCount")]
    public int? HumanCountQuery { get; set; }

    [SupplyParameterFromQuery]
    public string? pawns { get; set; }

    private List<BoardSpaceDto> BoardSpaces { get; set; } = new();

    // template lookup by position for the currently loaded board
    private Dictionary<int, BlockTemplateEntity> _templatesByPosition = new();

    private Game? _game;
    private bool _loading = true;

    private int Rows;
    private int Cols;
    private int CellSize;
    private List<(int r, int c)> Perimeter = new();

    private string PawnUrl = "/images/pawns/PawnsB1.png";

    private int _pawnAnimPosition = -1;
    private bool _isAnimating;
    private int _animStepMs = 140;

    // dice overlay
    private bool _showDiceOverlay;
    private int _diceFace1 = 1;
    private int _diceFace2 = 1;
    private string _rollingGifUrl = string.Empty;
    private readonly Random _rand = new();

    private const double _boardScale = 1.5;
    private string _boardWidthCss = "0px";
    private string _boardHeightCss = "0px";

    // pawn selection per player
    private List<int> _pawnsForPlayers = new();

    // modal state for post-move actions
    private bool _showBlockModal;
    private Block? _modalBlock;
    private Player? _modalPlayer;
    private int _preMovePlayerMoney;
    private bool _modalFromMove;

    // optional template entity for the modal and a merged property used for display
    private BlockTemplateEntity? _modalTemplateEntity;
    private PropertyBlock? _modalDisplayProperty;

    // pending action for deferred blocks (Tax/Chance/Reves)
    private enum PendingActionKind { None, Tax, Chance, Reves }
    private PendingActionKind _pendingActionKind = PendingActionKind.None;
    private int _pendingAmount = 0; // money to add/subtract
    private int _pendingBackSteps = 0; // for Reves backward movement

    // winner/loser modals
    private bool _showWinnerModal;
    private string _winnerName = string.Empty;
    private bool _showLoserModal;
    private string _loserName = string.Empty;

    // Bot action toast helpers
    private bool _showBotActionToast;
    private string _botActionMessage = string.Empty;
    // bot modal action guard
    private bool _botHasActedThisModal = false;

    protected override async Task OnParametersSetAsync()
    {
        _loading = true;
        if (!boardId.HasValue)
        {
            // no board selected, navigate back
            Nav.NavigateTo("/local");
            return;
        }

        await LoadBoardLayoutAsync(boardId.Value);
        _game = await GameRepo.GetGameAsync(GameId);
        if (_game is not null)
        {
            _pawnAnimPosition = _game.Players.FirstOrDefault()?.CurrentPosition ?? 0;
            // prefer persisted pawns
            _pawnsForPlayers = _game.Players.Select(p => Math.Clamp(p.PawnIndex, 1, 6)).ToList();
        }

        // if no pawns persisted, parse pawns query param
        if (!_pawnsForPlayers.Any())
            ParsePawnsQuery();

        // load pawn image from session
        try
        {
            var pawn = await Profiles.GetPawnFromSessionAsync();
            if (!string.IsNullOrWhiteSpace(pawn)) PawnUrl = pawn;
        }
        catch { }

        _loading = false;
        StateHasChanged();

        // if current player is bot, trigger automatic roll
        await TryAutoRollForBotAsync();
    }

    private void ParsePawnsQuery()
    {
        _pawnsForPlayers.Clear();
        if (string.IsNullOrWhiteSpace(pawns)) return;
        var parts = pawns.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        foreach (var p in parts)
        {
            if (int.TryParse(p, out var v)) _pawnsForPlayers.Add(Math.Clamp(v, 1, 6));
        }
    }

    private string GetPawnUrlForPlayer(int playerIndex)
    {
        if (playerIndex < _pawnsForPlayers.Count)
        {
            var idx = _pawnsForPlayers[playerIndex];
            return $"{Nav.BaseUri}images/pawns/PawnsB{idx}.png";
        }
        return PawnUrl; // fallback
    }

    private async Task LoadBoardLayoutAsync(Guid bId)
    {
        await using var db = await DbFactory.CreateDbContextAsync();
        var board = await db.Boards.AsNoTracking().FirstOrDefaultAsync(b => b.Id == bId);
        if (board is null) return;
        Rows = board.Rows;
        Cols = board.Cols;
        CellSize = board.CellSizePx;
        Perimeter = BuildPerimeterClockwise(Rows, Cols);

        var templates = await db.BlockTemplates.AsNoTracking()
            .Where(t => t.BoardDefinitionId == bId)
            .OrderBy(t => t.Position)
            .ToListAsync();

        // store templates by position so modal can show full static data
        _templatesByPosition = templates.ToDictionary(t => t.Position, t => t);

        BoardSpaces = new List<BoardSpaceDto>(Perimeter.Count);
        for (int i = 0; i < Perimeter.Count; i++)
        {
            var (r, c) = Perimeter[i];
            var template = templates.ElementAtOrDefault(i);
            var img = template != null && !string.IsNullOrWhiteSpace(template.ImageUrl)
                ? template.ImageUrl
                : GetImageForType(template?.Type ?? BlockType.Property);

            string? overlay = null;
            if (template != null && template.Type == BlockType.Property && template.Level.HasValue)
            {
                overlay = GetLevelOverlayColor(template.Level.Value);
            }

            BoardSpaces.Add(new BoardSpaceDto
            {
                Id = $"space-{i}",
                Name = (template != null ? template.Name : $"Space {i}"),
                ImageUrl = img,
                OverlayColor = overlay,
                Style = new BoardSpaceStyle
                {
                    Top = $"{(int)(r * CellSize * _boardScale)}px",
                    Left = $"{(int)(c * CellSize * _boardScale)}px",
                    Width = $"{(int)(CellSize * _boardScale)}px",
                    Height = $"{(int)(CellSize * _boardScale)}px"
                }
            });
        }

        var boardWidth = (int)(Cols * CellSize * _boardScale);
        var boardHeight = (int)(Rows * CellSize * _boardScale);
        _boardWidthCss = boardWidth + "px";
        _boardHeightCss = boardHeight + "px";
    }

    private async Task RollForCurrentPlayer()
    {
        if (_game is null || _isAnimating) return;

        // ensure only current human can roll
        var humanCount = GetHumanPlayersCount();
        if (_game.CurrentPlayerIndex >= humanCount) return; // not human

        await RollAndMove();
    }

    private async Task RollAndMove()
    {
        if (_game is null || _isAnimating) return;

        // If current player starts turn with negative money, they are eliminated
        var currentPlayer = _game.Players[_game.CurrentPlayerIndex];
        if (currentPlayer.Money < 0)
        {
            await RegisterLoserAsync(currentPlayer);
            return;
        }

        _isAnimating = true;

        var (die1, die2, total) = _game.RollDice();

        await ShowDiceAnimationAsync(die1, die2);

        // animate token movement
        var playerIndex = _game.CurrentPlayerIndex;
        var player = _game.Players[playerIndex];

        var startPos = player.CurrentPosition;
        var steps = total;
        var pos = startPos;
        for (int i = 0; i < steps; i++)
        {
            pos = (pos + 1) % Perimeter.Count;
            // animate all tokens accordingly by updating _pawnAnimPosition temporarily
            _pawnAnimPosition = pos;
            StateHasChanged();
            try { await Task.Delay(_animStepMs); } catch { }
        }

        // apply move to model (do not execute Tax/Chance/Reves actions here — defer)
        _preMovePlayerMoney = player.Money;
        await _game.MoveCurrentPlayerAsync(total);

        // persist intermediate state so rent/tax results are saved even if user reloads
        await GameRepo.SaveGameAsync(GameId, _game);

        // prepare pending action for Tax/Chance/Reves (defer application until modal close)
        var landed = _game.Board.FirstOrDefault(b => b.Position == player.CurrentPosition);
        _pendingActionKind = PendingActionKind.None;
        _pendingAmount = 0;
        _pendingBackSteps = 0;

        if (landed is not null)
        {
            if (landed.Type == BlockType.Tax)
            {
                var percents = new[] { 5, 10, 15, 20, 25, 30 };
                var pct = percents[_rand.Next(percents.Length)];
                var taxAmount = (int)Math.Round(player.Money * pct / 100.0);
                _pendingActionKind = PendingActionKind.Tax;
                _pendingAmount = taxAmount;
                // store on block for display later
                landed.Rent = taxAmount;
            }
            else if (landed.Type == BlockType.Chance)
            {
                var choices = new[] { 50, 100, 150, 200, 300, 350, 400, 500, 600, 700 };
                var amount = choices[_rand.Next(choices.Length)];
                _pendingActionKind = PendingActionKind.Chance;
                _pendingAmount = amount;
            }
            else if (landed.Type == BlockType.Reves)
            {
                var takeMoneyOptions = new[] { 100, 200 };
                var willTakeMoney = (_rand.NextDouble() < 0.5);
                if (willTakeMoney)
                {
                    var amount = takeMoneyOptions[_rand.Next(takeMoneyOptions.Length)];
                    _pendingActionKind = PendingActionKind.Reves;
                    _pendingAmount = amount;
                    _pendingBackSteps = 0;
                }
                else
                {
                    var backSteps = _rand.Next(2, 7);
                    _pendingActionKind = PendingActionKind.Reves;
                    _pendingBackSteps = backSteps;
                    _pendingAmount = 0;
                }
            }
        }

        // open modal with info/actions for the landed block and delay turn advancement until player closes it
        _modalPlayer = player;
        _modalBlock = _game.Board.FirstOrDefault(b => b.Position == player.CurrentPosition);

        // get matching template (if any) for richer static data
        _modalTemplateEntity = _templatesByPosition.TryGetValue(player.CurrentPosition, out var tpl) ? tpl : null;
        // build display property merging template(static) + game state(dynamic)
        _modalDisplayProperty = BuildDisplayProperty(_modalBlock, _modalTemplateEntity);

        _pawnAnimPosition = -1;
        _isAnimating = false;
        _modalFromMove = true;
        _showBlockModal = true;
        StateHasChanged();

        // if actor is bot, start automated modal actions (do not await here so UI can render)
        var humanCount = GetHumanPlayersCount();
        var actorIndex = GetPlayerIndex(player.Id);
        _botHasActedThisModal = false;
        if (actorIndex >= humanCount)
        {
            _ = InvokeAsync(async () =>
            {
                // small delay to ensure modal is rendered
                try { await Task.Delay(150); } catch { }
                await BotActOnModalAsync();
            });
        }

        // do NOT call NextTurn here; NextTurn will be called when player closes modal
    }

    private async Task ApplyPendingActionAsync()
    {
        if (_game is null || _modalPlayer is null || _pendingActionKind == PendingActionKind.None) return;
        var playerIndex = GetPlayerIndex(_modalPlayer.Id);
        var player = _modalPlayer;
        var landed = _game.Board.FirstOrDefault(b => b.Position == player.CurrentPosition);

        if (_pendingActionKind == PendingActionKind.Tax)
        {
            player.Money = Math.Max(0, player.Money - _pendingAmount);
            if (landed is not null) landed.Rent = _pendingAmount;
        }
        else if (_pendingActionKind == PendingActionKind.Chance)
        {
            player.Money += _pendingAmount;
        }
        else if (_pendingActionKind == PendingActionKind.Reves)
        {
            if (_pendingBackSteps > 0)
            {
                // animate backward and update position
                await AnimateBackwardAsync(playerIndex, _pendingBackSteps);
            }
            else if (_pendingAmount > 0)
            {
                player.Money = Math.Max(0, player.Money - _pendingAmount);
            }
        }

        // persist result
        await GameRepo.SaveGameAsync(GameId, _game);

        // clear pending
        _pendingActionKind = PendingActionKind.None;
        _pendingAmount = 0;
        _pendingBackSteps = 0;
    }

    private async Task CloseBlockModal()
    {
        _showBlockModal = false;

        // if modal was opened as result of a move, apply pending action then possibly allow bot buys/builds, then advance
        if (_modalFromMove)
        {
            if (_game is not null && _modalPlayer is not null)
            {
                // apply pending tax/chance/reves
                await ApplyPendingActionAsync();

                // check bankruptcy after applying pending
                if (_modalPlayer.Money < 0)
                {
                    await RegisterLoserAsync(_modalPlayer);
                    // if game ended due to single winner, don't proceed to next turn
                    _modalFromMove = false;
                    _modalTemplateEntity = null;
                    _modalDisplayProperty = null;
                    StateHasChanged();
                    return;
                }

                // If actor was bot, perform auto-purchase and auto-build (fallback if modal automation didn't run)
                var humanCount = GetHumanPlayersCount();
                var actorIndex = GetPlayerIndex(_modalPlayer.Id);
                if (actorIndex >= humanCount && !_botHasActedThisModal)
                {
                    if (_modalBlock is not null && _modalBlock.Owner is null && (_modalBlock.Type == BlockType.Property || _modalBlock.Type == BlockType.Company))
                    {
                        if (_modalPlayer.Money >= _modalBlock.Price)
                        {
                            _game.TryBuyProperty(_modalPlayer, _modalBlock);
                            await GameRepo.SaveGameAsync(GameId, _game);
                            await ShowBotActionToast($"{_modalPlayer.Name} comprou {_modalBlock.Name}");
                        }
                    }

                    if (_modalBlock is PropertyBlock pb && pb.Owner == _modalPlayer)
                    {
                        if (CanBuildHouseAllowed(pb))
                        {
                            var ok = pb.BuildHouse(_modalPlayer);
                            if (ok)
                            {
                                _modalPlayer.LastBuildTurn = _game.RoundCount;
                                await GameRepo.SaveGameAsync(GameId, _game);
                                await ShowBotActionToast($"{_modalPlayer.Name} construiu casa em {pb.Name}");
                            }
                        }
                        else if (CanBuildHotelAllowed(pb))
                        {
                            var ok = pb.BuildHotel(_modalPlayer);
                            if (ok)
                            {
                                _modalPlayer.LastBuildTurn = _game.RoundCount;
                                await GameRepo.SaveGameAsync(GameId, _game);
                                await ShowBotActionToast($"{_modalPlayer.Name} construiu hotel em {pb.Name}");
                            }
                        }
                    }
                    try { await Task.Delay(400); } catch { }
                }

                // advance turn
                _game.NextTurn();
                await GameRepo.SaveGameAsync(GameId, _game);
            }
        }

        _modalFromMove = false;
        _modalTemplateEntity = null;
        _modalDisplayProperty = null;
        StateHasChanged();

        // after closing modal, if next player is bot and ready, trigger auto roll
        await TryAutoRollForBotAsync();
    }

    private async Task RegisterLoserAsync(Player player)
    {
        if (_game is null) return;
        player.IsBankrupt = true;
        // release ownership
        foreach (var prop in player.OwnedProperties)
        {
            prop.Owner = null;
            prop.IsMortgaged = false;
        }
        player.OwnedProperties.Clear();

        _loserName = player.Name;

        // count active players
        var active = _game.Players.Count(p => !p.IsBankrupt);
        if (active == 1)
        {
            // find winner
            var winner = _game.Players.FirstOrDefault(p => !p.IsBankrupt);
            if (winner is not null)
            {
                _winnerName = winner.Name;
                _showWinnerModal = true;
                _showLoserModal = false;
                _game.Finish();
                await GameRepo.SaveGameAsync(GameId, _game);
            }
        }
        else
        {
            _showLoserModal = true;
            _showWinnerModal = false;
            await GameRepo.SaveGameAsync(GameId, _game);
            // advance turn since this player's turn is skipped
            _game.NextTurn();
        }

        StateHasChanged();
    }

    private void CloseLoserModal()
    {
        _showLoserModal = false;
        StateHasChanged();
        _ = TryAutoRollForBotAsync();
    }

    private void CloseWinnerModal()
    {
        _showWinnerModal = false;
        StateHasChanged();
    }

    private async Task OnBuyPropertyAsync()
    {
        if (_modalBlock is PropertyBlock pb && _modalPlayer is not null)
        {
            var success = _game.TryBuyProperty(_modalPlayer, pb);
            if (success)
            {
                if (_game is not null) await GameRepo.SaveGameAsync(GameId, _game);
            }
        }
        else if (_modalBlock is not null && _modalBlock.Type == BlockType.Company && _modalPlayer is not null)
        {
            var success = _game.TryBuyProperty(_modalPlayer, _modalBlock);
            if (success)
            {
                if (_game is not null) await GameRepo.SaveGameAsync(GameId, _game);
            }
        }
        StateHasChanged();
    }

    private async Task OnBuildHouseAsync()
    {
        if (_modalBlock is PropertyBlock pb && _modalPlayer is not null && _game is not null)
        {
            if (!CanBuildHouseAllowed(pb)) return;
            var ok = pb.BuildHouse(_modalPlayer);
            if (ok)
            {
                // record build turn to enforce 1 build per round
                _modalPlayer.LastBuildTurn = _game.RoundCount;
                if (_game is not null) await GameRepo.SaveGameAsync(GameId, _game);
            }
        }
        StateHasChanged();
    }

    private async Task OnBuildHotelAsync()
    {
        if (_modalBlock is PropertyBlock pb && _modalPlayer is not null && _game is not null)
        {
            if (!CanBuildHotelAllowed(pb)) return;
            var ok = pb.BuildHotel(_modalPlayer);
            if (ok)
            {
                // record build turn to enforce 1 build per round
                _modalPlayer.LastBuildTurn = _game.RoundCount;
                if (_game is not null) await GameRepo.SaveGameAsync(GameId, _game);
            }
        }
        StateHasChanged();
    }

    private async Task OnSellPropertyAsync()
    {
        if (_modalBlock is PropertyBlock pb && pb.Owner is not null)
        {
            var owner = pb.Owner;
            // remove ownership and pay owner half price
            owner.Money += pb.Price / 2;
            owner.OwnedProperties.Remove(pb);
            pb.Owner = null;
            pb.IsMortgaged = false;
            if (_game is not null) await GameRepo.SaveGameAsync(GameId, _game);
        }
        StateHasChanged();
    }

    private bool CanBuildHouseAllowed(PropertyBlock pb)
    {
        if (_game is null || _modalPlayer is null) return false;
        // must be owner
        if (pb.Owner != _modalPlayer) return false;
        // pawn must be on this property
        if (_modalPlayer.CurrentPosition != pb.Position) return false;
        // must be at least next round after last purchase
        if (_modalPlayer.LastPurchaseTurn >= 0 && _game.RoundCount <= _modalPlayer.LastPurchaseTurn) return false;
        // only one build per round
        if (_modalPlayer.LastBuildTurn == _game.RoundCount) return false;
        // must own all properties of same level
        if (!PlayerOwnsAllOfLevel(_modalPlayer, pb.Level)) return false;
        // house-specific checks
        if (!pb.CanBuildHouse()) return false;
        if (_modalPlayer.Money < pb.HousePrice) return false;
        return true;
    }

    private bool CanBuildHotelAllowed(PropertyBlock pb)
    {
        if (_game is null || _modalPlayer is null) return false;
        if (pb.Owner != _modalPlayer) return false;
        if (_modalPlayer.CurrentPosition != pb.Position) return false;
        if (_modalPlayer.LastPurchaseTurn >= 0 && _game.RoundCount <= _modalPlayer.LastPurchaseTurn) return false;
        if (_modalPlayer.LastBuildTurn == _game.RoundCount) return false;
        if (!PlayerOwnsAllOfLevel(_modalPlayer, pb.Level)) return false;
        if (!pb.CanBuildHotel()) return false;
        if (_modalPlayer.Money < pb.HotelPrice) return false;
        return true;
    }

    private bool PlayerOwnsAllOfLevel(Player player, PropertyLevel level)
    {
        if (_game is null) return false;
        var boardProps = _game.Board.OfType<PropertyBlock>().Where(b => b.Level == level).ToList();
        if (!boardProps.Any()) return false;
        foreach (var bp in boardProps)
        {
            if (bp.Owner != player) return false;
        }
        return true;
    }

    private async Task ShowDiceAnimationAsync(int finalDie1, int finalDie2)
    {
        try
        {
            var gifIndex = _rand.Next(1, 13);
            _rollingGifUrl = $"{Nav.BaseUri}images/diceAnim/dice-rolling-{gifIndex}.gif";

            _showDiceOverlay = true;
            StateHasChanged();

            var animDurationMs = 800;
            var frameMs = 80;
            var frames = Math.Max(1, animDurationMs / frameMs);

            for (int i = 0; i < frames; i++)
            {
                _diceFace1 = _rand.Next(1, 7);
                _diceFace2 = _rand.Next(1, 7);
                StateHasChanged();
                try { await Task.Delay(frameMs); } catch { }
            }

            _diceFace1 = Math.Clamp(finalDie1, 1, 6);
            _diceFace2 = Math.Clamp(finalDie2, 1, 6);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ShowDiceAnimationAsync error: {ex}");
        }
        finally
        {
            _showDiceOverlay = false;
            _rollingGifUrl = string.Empty;
            StateHasChanged();
        }
    }

    private (string top, string left, int z) GetTokenOffsetPosition(Player p, int playerIndex)
    {
        var boardIndex = Math.Clamp(p.CurrentPosition, 0, Math.Max(0, Perimeter.Count - 1));
        var (r, c) = Perimeter[boardIndex];
        var baseTop = (int)(r * CellSize * _boardScale);
        var baseLeft = (int)(c * CellSize * _boardScale);
        var cellScaled = (int)(CellSize * _boardScale);
        int offsetX = 0, offsetY = 0;
        switch (playerIndex)
        {
            case 0:
                offsetX = 0; offsetY = 0; break;
            case 1:
                offsetX = (int)(cellScaled * 0.28); offsetY = 0; break;
            case 2:
                offsetX = 0; offsetY = (int)(cellScaled * 0.28); break;
            case 3:
                offsetX = (int)(cellScaled * 0.28); offsetY = (int)(cellScaled * 0.28); break;
        }

        // add a tiny extra spacing so pawns are not touching each other (2px right/down for shifted pawns)
        const int extraSpacingX = 2; // px to add horizontally for right-side pawns
        const int extraSpacingY = 2; // px to add vertically for bottom pawns
        if (offsetX > 0) offsetX += extraSpacingX;
        if (offsetY > 0) offsetY += extraSpacingY;

        var top = (baseTop + offsetY) + "px";
        var left = (baseLeft + offsetX) + "px";
        var z = playerIndex >= 2 ? 1200 : 1100;
        return (top, left, z);
    }

    private (string top, string left, int z) GetTokenOffsetPositionByBoardIndex(int boardIndex, int playerIndex)
    {
        var (r, c) = Perimeter[Math.Clamp(boardIndex, 0, Perimeter.Count - 1)];
        var baseTop = (int)(r * CellSize * _boardScale);
        var baseLeft = (int)(c * CellSize * _boardScale);
        var cellScaled = (int)(CellSize * _boardScale);
        int offsetX = 0, offsetY = 0;
        switch (playerIndex)
        {
            case 0:
                offsetX = 0; offsetY = 0; break;
            case 1:
                offsetX = (int)(cellScaled * 0.28); offsetY = 0; break;
            case 2:
                offsetX = 0; offsetY = (int)(cellScaled * 0.28); break;
            case 3:
                offsetX = (int)(cellScaled * 0.28); offsetY = (int)(cellScaled * 0.28); break;
        }

        // add the same small spacing here as well
        const int extraSpacingX = 12; // px
        const int extraSpacingY = 6; // px
        if (offsetX > 0) offsetX += extraSpacingX;
        if (offsetY > 0) offsetY += extraSpacingY;

        var top = (baseTop + offsetY) + "px";
        var left = (baseLeft + offsetX) + "px";
        var z = playerIndex >= 2 ? 1200 : 1100;
        return (top, left, z);
    }

    private int GetHumanPlayersCount()
    {
        if (HumanCountQuery.HasValue) return Math.Max(0, HumanCountQuery.Value);
        try
        {
            var uri = Nav.ToAbsoluteUri(Nav.Uri);
            var q = QueryHelpers.ParseQuery(uri.Query);
            string? v = null;
            if (q.TryGetValue("humanCount", out var hv)) v = hv.ToString();
            else if (q.TryGetValue("humancount", out var hv2)) v = hv2.ToString();
            if (!string.IsNullOrWhiteSpace(v) && int.TryParse(v, out var parsed)) return Math.Max(0, parsed);
        }
        catch { }
        return 1;
    }

    private bool CanRollForCurrent => !_isAnimating && _game is not null && (_game.CurrentPlayerIndex < GetHumanPlayersCount());

    private Task EndGame()
    {
        Nav.NavigateTo("/");
        return Task.CompletedTask;
    }

    private async Task HandleClick(BoardSpaceDto space)
    {
        if (_game is null || space is null) return;
        // parse position from id 'space-{index}'
        var id = space.Id ?? string.Empty;
        var parts = id.Split('-', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        if (parts.Length < 2) return;
        if (!int.TryParse(parts[1], out var pos)) return;

        var block = _game.Board.FirstOrDefault(b => b.Position == pos);
        if (block is null) return;

        // modal opened manually by user click: do not advance turn on close
        _modalFromMove = false;
        _modalBlock = block;
        // use current player as actor
        _modalPlayer = _game.Players.ElementAtOrDefault(_game.CurrentPlayerIndex);
        _preMovePlayerMoney = _modalPlayer?.Money ?? 0;

        // also set matching template and build merged display property
        _modalTemplateEntity = _templatesByPosition.TryGetValue(pos, out var tmpl) ? tmpl : null;
        _modalDisplayProperty = BuildDisplayProperty(_modalBlock, _modalTemplateEntity);

        _showBlockModal = true;
        StateHasChanged();
    }

    // Helpers
    private PropertyBlock? BuildDisplayProperty(Block? stateBlock, BlockTemplateEntity? template)
    {
        PropertyBlock pb = null;
        if (template is not null)
        {
            pb = new PropertyBlock
            {
                Position = template.Position,
                Name = template.Name,
                Description = template.Description,
                ImageUrl = template.ImageUrl,
                Color = template.Color,
                Price = template.Price,
                HousePrice = template.HousePrice,
                HotelPrice = template.HotelPrice,
                Level = template.Level ?? PropertyLevel.Barata
            };
            if (IsGenericTemplateName(pb.Name)) pb.Name = GetNeighborhoodName(pb.Level, template.Position);
            if (!string.IsNullOrWhiteSpace(template.RentsCsv))
            {
                var parts = template.RentsCsv.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
                for (int i = 0; i < Math.Min(parts.Length, pb.Rents.Length); i++) if (int.TryParse(parts[i], out var v)) pb.Rents[i] = v;
            }
        }

        if (stateBlock is PropertyBlock statePb)
        {
            if (pb is null) { statePb.Rents = statePb.Rents ?? new int[7]; return statePb; }
            pb.Houses = statePb.Houses;
            pb.Hotels = statePb.Hotels;
            pb.IsMortgaged = statePb.IsMortgaged;
            pb.Owner = statePb.Owner;
            if (pb.Rents[0] == 0 && statePb.Rent > 0) pb.Rents[0] = statePb.Rent;
            return pb;
        }

        return pb;
    }

    private static bool IsGenericTemplateName(string? name)
    {
        if (string.IsNullOrWhiteSpace(name)) return true;
        if (name.StartsWith("Propriedade", StringComparison.OrdinalIgnoreCase)) return true;
        if (name.StartsWith("Bloco", StringComparison.OrdinalIgnoreCase)) return true;
        return false;
    }

    private static string GetNeighborhoodName(PropertyLevel level, int position)
    {
        var list = level switch
        {
            PropertyLevel.MuitoRica => new[] { "Leblon", "Ipanema", "Jardim Botânico", "São Conrado", "Lagoa" },
            PropertyLevel.Rica => new[] { "Copacabana", "Flamengo", "Botafogo", "Gávea", "Laranjeiras" },
            PropertyLevel.Mediana => new[] { "Humaitá", "Leme", "Maracanã", "Tijuca", "Andaraí" },
            PropertyLevel.Barata => new[] { "Madureira", "Bonsucesso", "Campo Grande", "Realengo", "Paciência" },
            _ => new[] { "Propriedade 1", "Propriedade 2", "Propriedade 3", "Propriedade 4", "Propriedade 5" }
        };
        if (list.Length == 0) return "Propriedade";
        var idx = Math.Abs(position) % list.Length;
        return list[idx];
    }

    private async Task TryAutoRollForBotAsync()
    {
        if (_game is null) return;
        var humanPlayers = GetHumanPlayersCount();
        var currentIndex = _game.CurrentPlayerIndex;
        if (currentIndex >= humanPlayers && currentIndex < _game.Players.Count)
        {
            try { await Task.Delay(700); } catch { }
            if (!_isAnimating) await RollAndMove();
        }
    }

    private static List<(int r, int c)> BuildPerimeterClockwise(int rows, int cols)
    {
        var list = new List<(int r, int c)>(Math.Max(0, 2 * rows + 2 * cols - 4));
        if (rows < 2 || cols < 2) return list;
        int bottom = rows - 1; int top = 0; int left = 0; int right = cols - 1;
        for (int c = right; c >= left; c--) list.Add((bottom, c));
        for (int r = bottom - 1; r >= top; r--) list.Add((r, left));
        for (int c = left + 1; c <= right; c++) list.Add((top, c));
        for (int r = top + 1; r <= bottom - 1; r++) list.Add((r, right));
        return list;
    }

    private static string GetImageForType(BlockType? type) => type switch
    {
        BlockType.Go => "/images/blocks/property_basic.svg",
        BlockType.Property => "/images/blocks/property_basic.svg",
        BlockType.Company => "/images/blocks/property_predio.svg",
        BlockType.Jail => "/images/blocks/visitar_prisao.svg",
        BlockType.GoToJail => "/images/blocks/go_to_jail.svg",
        BlockType.Tax => "/images/blocks/volte-casas.svg",
        _ => "/images/blocks/property_basic.svg"
    };

    private string GetLevelOverlayColor(PropertyLevel lvl) => lvl switch
    {
        PropertyLevel.Barata => "rgba(139,69,19,0.5)",
        PropertyLevel.Mediana => "rgba(52,152,219,0.5)",
        PropertyLevel.Rica => "rgba(155,89,182,0.5)",
        PropertyLevel.MuitoRica => "rgba(46,204,113,0.5)",
        _ => "rgba(0,0,0,0.5)"
    };

    private string TranslateBlockType(BlockType t) => t switch
    {
        BlockType.Go => "Início",
        BlockType.Property => "Propriedade",
        BlockType.Company => "Companhia",
        BlockType.Tax => "Taxa",
        BlockType.Jail => "Visitar Prisão",
        BlockType.GoToJail => "Vá para Prisão",
        BlockType.Chance => "Sorte",
        BlockType.Reves => "Revés",
        BlockType.FreeParking => "Parada Livre",
        _ => t.ToString()
    };

    // Animate backward movement (used by Reves pending action)
    private async Task AnimateBackwardAsync(int playerIndex, int steps)
    {
        if (_game is null || playerIndex < 0 || playerIndex >= _game.Players.Count) return;
        var previousAnimating = _isAnimating;
        _isAnimating = true;
        var player = _game.Players[playerIndex];
        var pos = player.CurrentPosition;
        for (int i = 0; i < steps; i++)
        {
            pos = (pos - 1 + Perimeter.Count) % Perimeter.Count;
            _pawnAnimPosition = pos;
            StateHasChanged();
            try { await Task.Delay(_animStepMs); } catch { }
        }
        player.CurrentPosition = pos;
        _pawnAnimPosition = -1;
        _isAnimating = previousAnimating;
    }

    private int GetPlayerIndex(Guid playerId)
    {
        if (_game is null) return -1;
        for (int i = 0; i < _game.Players.Count; i++) if (_game.Players[i].Id == playerId) return i;
        return -1;
    }

    // Bot action toast helpers
    private async Task ShowBotActionToast(string message)
    {
        _botActionMessage = message;
        _showBotActionToast = true;
        StateHasChanged();
        try { await Task.Delay(1200); } catch { }
        _showBotActionToast = false;
        StateHasChanged();
    }

    // Bot modal automation: simulate buy/build then close modal after 2s
    private async Task BotActOnModalAsync()
    {
        if (_game is null || _modalPlayer is null || !_modalFromMove) return;
        var humanCount = GetHumanPlayersCount();
        var actorIndex = GetPlayerIndex(_modalPlayer.Id);
        if (actorIndex < humanCount) return;

        bool clicked = false;
        try
        {
            clicked = await JSRuntime.InvokeAsync<bool>("playInterop.clickModalButton", "buy");
        }
        catch { }

        if (!clicked)
        {
            try
            {
                clicked = await JSRuntime.InvokeAsync<bool>("playInterop.clickModalButton", "build-house");
                if (!clicked) clicked = await JSRuntime.InvokeAsync<bool>("playInterop.clickModalButton", "build-hotel");
            }
            catch { }
        }

        if (clicked) _botHasActedThisModal = true;

        // if JS couldn't simulate a click, fallback to C# actions
        if (!clicked)
        {
            if (_modalBlock is not null && _modalBlock.Owner is null && (_modalBlock.Type == BlockType.Property || _modalBlock.Type == BlockType.Company))
            {
                if (_modalPlayer.Money >= _modalBlock.Price)
                {
                    _botHasActedThisModal = true;
                    _game.TryBuyProperty(_modalPlayer, _modalBlock);
                    await GameRepo.SaveGameAsync(GameId, _game);
                    await ShowBotActionToast($"{_modalPlayer.Name} comprou {_modalBlock.Name}");
                }
            }

            if (_modalBlock is PropertyBlock pb && pb.Owner == _modalPlayer)
            {
                if (CanBuildHouseAllowed(pb))
                {
                    var ok = pb.BuildHouse(_modalPlayer);
                    if (ok)
                    {
                        _modalPlayer.LastBuildTurn = _game.RoundCount;
                        await GameRepo.SaveGameAsync(GameId, _game);
                        await ShowBotActionToast($"{_modalPlayer.Name} construiu casa em {pb.Name}");
                        _botHasActedThisModal = true;
                    }
                }
                else if (CanBuildHotelAllowed(pb))
                {
                    var ok = pb.BuildHotel(_modalPlayer);
                    if (ok)
                    {
                        _modalPlayer.LastBuildTurn = _game.RoundCount;
                        await GameRepo.SaveGameAsync(GameId, _game);
                        await ShowBotActionToast($"{_modalPlayer.Name} construiu hotel em {pb.Name}");
                        _botHasActedThisModal = true;
                    }
                }
            }
        }

        // wait 2s and close modal
        try { await Task.Delay(2000); } catch { }
        await InvokeAsync(async () => await CloseBlockModal());
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (!firstRender) return;
        // ensure game loaded and if first player is bot, trigger roll
        if (_game is not null)
        {
            var humanCount = GetHumanPlayersCount();
            if (_game.CurrentPlayerIndex >= humanCount)
            {
                try { await Task.Delay(300); } catch { }
                try {
                    if (!_isAnimating) await RollAndMove();
                } catch { }
            }
        }
    }
}
