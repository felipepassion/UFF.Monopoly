@page "/"

@using Microsoft.EntityFrameworkCore
@using UFF.Monopoly.Data
@using UFF.Monopoly.Data.Entities
@using UFF.Monopoly.Models
@using UFF.Monopoly.Repositories
@using UFF.Monopoly.Entities
@using System.Globalization
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject IGameRepository GameRepo
@inject NavigationManager Nav
@inject UFF.Monopoly.Infrastructure.IUserProfileService Profiles

@rendermode InteractiveServer

<GameHeader Boards="Boards" SelectedBoardId="SelectedBoardId" IsGameRunning="IsGameRunning"
            @bind-PlayerName="PlayerName"
            OnBoardChanged="OnBoardChangedFromHeader" OnStart="StartGame" OnEnd="ResetGame" OnRoll="RollAndMove"
            OnPlayerNameChanged="OnPlayerNameChanged" OnPawnChanged="OnPawnChanged" />

<div class="mt-2 d-flex align-items-md-center justify-content-center full-center-wrapper" style="min-height: calc(100vh - 120px);">
    <div class="board-shell d-inline-block" style="background:var(--surface);border:1px solid rgba(255,255,255,0.03);border-radius:10px;padding:10px;">
        @* scale factor applied to board and all visuals *@
        @{
            const double scale = 1.5;
            var boardWidth = (int)(Cols * CellSize * scale);
            var boardHeight = (int)(Rows * CellSize * scale);
            var boardWidthCss = boardWidth + "px";
            var boardHeightCss = boardHeight + "px";
        }
        <div id="game-board-container" class="game-board" style="position:relative; width:@boardWidthCss; height:@boardHeightCss; display:flex; align-items:center; justify-content:center;">
            @foreach (var space in BoardSpaces)
            {
                <BoardSpace Space="space" OnClick="HandleClick" />
            }

            @if (_showDiceOverlay)
            {
                var diceImgSize = Math.Max(24, (int)(CellSize * 0.6 * scale)) + "px"; // scaled
                var gifSize = Math.Max(64, (int)(CellSize * 1.6 * scale)) + "px"; // scaled

                // offsets: move the gif up and the dice faces down so both are visible simultaneously (scaled)
                var gifOffsetPx = -(int)(CellSize * 0.6 * scale); // negative -> move up
                var diceOffsetPx = (int)(CellSize * 0.8 * scale); // positive -> move down
                var gifOffset = gifOffsetPx + "px";
                var diceOffset = diceOffsetPx + "px";

                <div class="dice-overlay" style="position:absolute; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center; pointer-events:auto;">
                    <div class="dice-faces" style="display:flex; gap:12px; align-items:center; z-index:1; transform:translateY(@diceOffset);">
                        <img src="@($"{Nav.BaseUri}images/dice/diceGreen{_diceFace1}.png")" alt="die1" style="width:@diceImgSize; height:@diceImgSize; object-fit:contain; z-index:1; pointer-events:none;" />
                        <img src="@($"{Nav.BaseUri}images/dice/diceGreen{_diceFace2}.png")" alt="die2" style="width:@diceImgSize; height:@diceImgSize; object-fit:contain; z-index:1; pointer-events:none;" />
                    </div>
                    @if (!string.IsNullOrWhiteSpace(_rollingGifUrl))
                    {
                        <img src="@_rollingGifUrl" alt="rolling" style="position:absolute; z-index:2; width:@gifSize; height:@gifSize; object-fit:contain; pointer-events:none; opacity:0.95; transform:translateY(@gifOffset);" />
                    }
                </div>
            }

            @if (IsGameRunning && CurrentPlayer is not null)
            {
                var renderIndex = _pawnAnimPosition >= 0 ? _pawnAnimPosition : CurrentPlayer.CurrentPosition;
                var (pxTop, pxLeft) = GetTokenPosition(renderIndex);
                var pawnSize = (CellSize * 0.45 * scale).ToString(CultureInfo.InvariantCulture) + "px";
                <img src="@PawnUrl" alt="pawn"
                     style="position:absolute; width:@pawnSize; height:@pawnSize; object-fit:contain; top:@pxTop; left:@pxLeft; transform:translate(20%,20%); transition: top @_animStepMs ms linear, left @_animStepMs ms linear; pointer-events:none;" />
            }
        </div>
    </div>
</div>

@code {
    private const string DefaultPawn = "/images/pawns/PawnsB1.png";

    private List<BoardDefinitionEntity> Boards = new();
    private Guid SelectedBoardId;
    private int Rows;
    private int Cols;
    private int CellSize;
    private List<(int r, int c)> Perimeter = new();

    private List<BoardSpaceDto> BoardSpaces { get; set; } = new();

    private Guid _gameId;
    private Game? _game;

    private bool IsGameRunning => _game is not null;
    private Player? CurrentPlayer => _game?.Players.FirstOrDefault();
    private string PlayerName { get; set; } = "Player 1";

    private string PawnUrl = DefaultPawn;

    private int _pawnAnimPosition = -1;
    private bool _isAnimating;
    private int _animStepMs = 140;

    // --- Dice overlay fields ---
    private bool _showDiceOverlay;
    private int _diceFace1 = 1;
    private int _diceFace2 = 1;
    private string _rollingGifUrl = string.Empty;
    // use instance Random to avoid any static initialization edge cases in Blazor component lifecycle
    private readonly Random _rand = new();

    // board scale factor - keep single source of truth
    private const double _boardScale = 1.5;

    protected override async Task OnInitializedAsync()
    {
        await LoadBoardsAsync();
        if (Boards.Any())
        {
            SelectedBoardId = Boards[0].Id;
            await LoadBoardLayoutAsync(SelectedBoardId);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        var pawn = await Profiles.GetPawnFromSessionAsync();
        if (!string.IsNullOrWhiteSpace(pawn))
        {
            PawnUrl = pawn;
            StateHasChanged();
        }
        else
        {
            // guarantee default pawn everywhere
            PawnUrl = DefaultPawn;
            await Profiles.SetPawnInSessionAsync(PawnUrl);
        }
    }

    private async Task LoadBoardsAsync()
    {
        await using var db = await DbFactory.CreateDbContextAsync();
        Boards = await db.Boards.AsNoTracking().OrderByDescending(b => b.CreatedAt).ToListAsync();
    }

    private async Task LoadBoardLayoutAsync(Guid boardId)
    {
        await using var db = await DbFactory.CreateDbContextAsync();
        var board = await db.Boards.AsNoTracking().FirstOrDefaultAsync(b => b.Id == boardId);
        if (board is null) return;
        Rows = board.Rows;
        Cols = board.Cols;
        CellSize = board.CellSizePx;
        Perimeter = BuildPerimeterClockwise(Rows, Cols);

        var templates = await db.BlockTemplates.AsNoTracking()
            .Where(t => t.BoardDefinitionId == boardId)
            .OrderBy(t => t.Position)
            .ToListAsync();
        BoardSpaces = new List<BoardSpaceDto>(Perimeter.Count);
        for (int i = 0; i < Perimeter.Count; i++)
        {
            var (r, c) = Perimeter[i];
            var img = i < templates.Count && !string.IsNullOrWhiteSpace(templates[i].ImageUrl)
                ? templates[i].ImageUrl
                : GetImageForType(templates.ElementAtOrDefault(i)?.Type ?? BlockType.Property);
            BoardSpaces.Add(new BoardSpaceDto
            {
                Id = $"space-{i}",
                Name = (i < templates.Count ? templates[i].Name : $"Space {i}"),
                ImageUrl = img,
                Style = new BoardSpaceStyle
                {
                    Top = $"{(int)(r * CellSize * _boardScale)}px",
                    Left = $"{(int)(c * CellSize * _boardScale)}px",
                    Width = $"{(int)(CellSize * _boardScale)}px",
                    Height = $"{(int)(CellSize * _boardScale)}px"
                }
            });
        }
    }

    private async Task StartGame()
    {
        if (SelectedBoardId == Guid.Empty) return;
        var (id, game) = await GameRepo.CreateNewGameAsync(SelectedBoardId, new[] { PlayerName });
        _gameId = id;
        _game = game;
        _pawnAnimPosition = CurrentPlayer?.CurrentPosition ?? 0;
        await Profiles.UpdateAsync(displayName: PlayerName, lastBoardId: SelectedBoardId);
        StateHasChanged();
    }

    private async Task RollAndMove()
    {
        if (_game is null || _isAnimating) return;

        // Prevent re-entry while dice animation + movement run
        _isAnimating = true;

        var (die1, die2, total) = _game.RollDice();

        // show dice overlay animation and final faces, wait 1s on final faces
        await ShowDiceAnimationAsync(die1, die2);

        // perform pawn animate + move
        await AnimateAndApplyAsync(total);
    }

    private async Task ShowDiceAnimationAsync(int finalDie1, int finalDie2)
    {
        try
        {
            var gifIndex = _rand.Next(1, 13);
            _rollingGifUrl = $"{Nav.BaseUri}images/diceAnim/dice-rolling-{gifIndex}.gif";

            _showDiceOverlay = true;
            StateHasChanged();

            var animDurationMs = 800;
            var frameMs = 80;
            var frames = Math.Max(1, animDurationMs / frameMs);

            for (int i = 0; i < frames; i++)
            {
                _diceFace1 = _rand.Next(1, 7);
                _diceFace2 = _rand.Next(1, 7);
                StateHasChanged();
                try { await Task.Delay(frameMs); } catch { }
            }

            _diceFace1 = Math.Clamp(finalDie1, 1, 6);
            _diceFace2 = Math.Clamp(finalDie2, 1, 6);
            StateHasChanged();
            try { await Task.Delay(1000); } catch { }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ShowDiceAnimationAsync error: {ex}");
        }
        finally
        {
            _showDiceOverlay = false;
            _rollingGifUrl = string.Empty;
            StateHasChanged();
        }
    }

    private async Task AnimateAndApplyAsync(int steps)
    {
        if (CurrentPlayer is null)
        {
            _isAnimating = false;
            return;
        }

        _isAnimating = true;
        if (_pawnAnimPosition < 0) _pawnAnimPosition = CurrentPlayer.CurrentPosition;

        for (int i = 0; i < steps; i++)
        {
            _pawnAnimPosition = (_pawnAnimPosition + 1 + Perimeter.Count) % Perimeter.Count;
            StateHasChanged();
            try { await Task.Delay(_animStepMs); } catch { }
        }

        await _game!.MoveCurrentPlayerAsync(steps);
        await GameRepo.SaveGameAsync(_gameId, _game);
        _pawnAnimPosition = -1;

        _isAnimating = false;
        StateHasChanged();
    }

    private Task ResetGame()
    {
        _game = null;
        _gameId = Guid.Empty;
        _pawnAnimPosition = -1;
        _isAnimating = false;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task HandleClick(BoardSpaceDto space)
    {
        Console.WriteLine($"id: {space.Id}");
        return Task.CompletedTask;
    }

    private async Task OnBoardChanged(ChangeEventArgs e)
    {
        if (Guid.TryParse(Convert.ToString(e.Value), out var id))
        {
            await OnBoardChangedFromHeader(id);
        }
    }

    private async Task OnBoardChangedFromHeader(Guid id)
    {
        SelectedBoardId = id;
        await Profiles.UpdateAsync(lastBoardId: SelectedBoardId);
        await LoadBoardLayoutAsync(SelectedBoardId);
        await ResetGame();
    }

    private async Task OnPlayerNameChanged(string name)
    {
        PlayerName = string.IsNullOrWhiteSpace(name) ? "Player 1" : name.Trim();
        await Profiles.UpdateAsync(displayName: PlayerName);
        StateHasChanged();
    }

    private Task OnPawnChanged(string url)
    {
        PawnUrl = string.IsNullOrWhiteSpace(url) ? DefaultPawn : url;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private (string top, string left) GetTokenPosition(int boardIndex)
    {
        boardIndex = Math.Clamp(boardIndex, 0, Math.Max(0, Perimeter.Count - 1));
        var (r, c) = Perimeter[boardIndex];
        return ($"{(int)(r * CellSize * _boardScale)}px", $"{(int)(c * CellSize * _boardScale)}px");
    }

    private static List<(int r, int c)> BuildPerimeterClockwise(int rows, int cols)
    {
        var list = new List<(int r, int c)>(Math.Max(0, 2 * rows + 2 * cols - 4));
        if (rows < 2 || cols < 2) return list;

        int bottom = rows - 1;
        int top = 0;
        int left = 0;
        int right = cols - 1;

        for (int c = right; c >= left; c--) list.Add((bottom, c));
        for (int r = bottom - 1; r >= top; r--) list.Add((r, left));
        for (int c = left + 1; c <= right; c++) list.Add((top, c));
        for (int r = top + 1; r <= bottom - 1; r++) list.Add((r, right));

        return list;
    }

    private static string GetImageForType(BlockType type) => type switch
    {
        BlockType.Go => "/images/blocks/property_basic.svg",
        BlockType.Property => "/images/blocks/property_basic.svg",
        BlockType.Jail => "/images/blocks/visitar_prisao.svg",
        BlockType.GoToJail => "/images/blocks/go_to_jail.svg",
        BlockType.Tax => "/images/blocks/volte-casas.svg",
        _ => "/images/blocks/property_basic.svg"
    };
}